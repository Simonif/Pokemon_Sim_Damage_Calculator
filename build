#!/usr/bin/env node
'use strict';

const path = require('path');
const fs = require('fs').promises;
const crypto = require('crypto');

const rootDir = '.';

// Update version
async function makeCachebuster(template, output) {
    let indexContents = await fs.readFile(path.resolve(rootDir, template), { encoding: 'utf8' });

    // Add hashes to js and css files
    process.stdout.write("Updating hashes... ");
    indexContents = indexContents.replace(/(src|href)="\.\/(.*?)\?[a-z0-9]*?"/g, async (a, b, c) => {
        let hash = Math.random(); // Just in case creating the hash fails
        try {
            const filename = c.replace('//play.pokemonshowdown.com/', '../../play.pokemonshowdown.com/');
            const fstr = await fs.readFile(path.resolve(rootDir, 'dist', filename), 'utf8');
            hash = crypto.createHash('md5').update(fstr).digest('hex').substr(0, 8);
        } catch (e) {
            console.error('Error reading file for hashing:', e);
        }

        return `${b}="./${c}?${hash}"`;
    }).replace(/\.template\.html/g, '.html');
    process.stdout.write("Writing new `" + output + "` file... ");
    await fs.writeFile(path.resolve(rootDir, output), indexContents);
    console.log("DONE");
}

async function cpdir(src, dest) {
    console.log("Copying `" + src + "` to `" + dest + "`");
    try {
        await fs.mkdir(dest, { recursive: true });
    } catch (e) {
        console.error('Error creating directory:', e);
        throw e;
    }

    const files = await fs.readdir(src);
    for (const file of files) {
        const srcPath = path.join(src, file);
        const destPath = path.join(dest, file);
        const current = await fs.lstat(srcPath);

        if (current.isDirectory()) {
            await cpdir(srcPath, destPath);
        } else if (current.isSymbolicLink()) {
            const symlink = await fs.readlink(srcPath);
            await fs.symlink(symlink, destPath);
        } else if (file.endsWith('.js')) {
            let contents = (await fs.readFile(srcPath, 'utf8')).replace(/^exports.* = void 0;$/gm, '');
            // Minify the sets so we save bandwidth
            if (src === 'src/js/data/sets') {
                const brkOpenIdx = contents.indexOf('{');
                contents = `${contents.slice(0, brkOpenIdx)}${JSON.stringify(JSON.parse(contents.slice(brkOpenIdx, -2)))};`
            }
            await fs.writeFile(destPath, contents);
        } else if (file.endsWith('.json')) {
            // Read and parse JSON files with error handling
            try {
                const jsonData = await fs.readFile(srcPath, 'utf8');
                const parsedData = JSON.parse(jsonData); // This might throw an error if the JSON is invalid
                await writeJsonFile(destPath, parsedData);
            } catch (error) {
                console.error('Error reading or parsing JSON file:', error);
                console.error('File contents:', await fs.readFile(srcPath, 'utf8'));
                throw error;
            }
        } else {
            await fs.copyFile(srcPath, destPath);
        }
    }
}

async function writeJsonFile(filePath, data) {
    const tempFilePath = `${filePath}.tmp`;
    const jsonData = JSON.stringify(data, null, 2);

    try {
        await fs.writeFile(tempFilePath, jsonData, 'utf8');
        await fs.rename(tempFilePath, filePath);
    } catch (error) {
        console.error('Error writing JSON file:', error);
        throw error;
    }
}

if (process.argv[2] !== 'view') {
    require('child_process').execSync('npm --prefix calc/ run compile', { stdio: 'inherit' });
}

(async () => {
    try {
        await cpdir('src', 'dist');
        await cpdir('calc/dist', 'dist/calc');
        await makeCachebuster('dist/honkalculate.template.html', 'dist/honkalculate.html');
        await makeCachebuster('dist/index.template.html', 'dist/index.html');
        await makeCachebuster('dist/randoms.template.html', 'dist/randoms.html');
        await makeCachebuster('dist/oms.template.html', 'dist/oms.html');
    } catch (error) {
        console.error('Error in build process:', error);
    }
})();
